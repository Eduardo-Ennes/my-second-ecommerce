name: "My-Second-Ecommerce"

services:
  express:
    container_name: express_MySecond_Ecommerce
    build:
    # Gera uma imagem a partir de um dockerfile
      context: ./backend/
      # dockerfile que está nesta pasta
      dockerfile: Dockerfile
      # arquivo dockerfile dentro da pasta
    environment:
      - PORT=${PORT}
      - DB_HOST=${DB_HOST}  # Deve ser o service do bd, no caso postgres 
      - DB_DATABASE=${DB_DATABASE} # My_Second_Ecommerce
      - DB_USER=${POSTGRES_USER}
      - DB_PASS=${POSTGRES_PASSWORD}
    ports:
      - 3000:8080
    volumes:
      - ./backend:/app              # monta o código local
      - /app/node_modules           # evita conflito com node_modules local
    command: npm run dev  
    networks:
      - my-second-ecommerce
    depends_on:
      postgres:
        condition: service_healthy  # O Express só vai ser iniciado quando o serviço postgres passar no healthcheck. 

  react:
    container_name: react_MySecond_Ecommerce
    build:
      context: ./frontend/
      dockerfile: Dockerfile
    ports: 
      - 5173:5173
    volumes:
      - ./frontend:/app             # monta o código local
      - /app/node_modules           # ignora node_modules local
    command: npm run dev  
    networks:
      - my-second-ecommerce
    depends_on:
      - express

  postgres:
    container_name: postgres_MySecond_Ecommerce
    image: postgres:17.6-alpine3.22
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${DB_DATABASE}    # My_Second_Ecommerce
    volumes: 
      - db_postgres_mySecond_Ecommerce:/var/lib/postgresql/data
    ports:
      - 5432:5432
    networks:
      - my-second-ecommerce
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 5s  # Define o intervalo entre cada checagem de saúde.
      timeout: 5s   # É o tempo máximo de espera para que o comando do healthcheck responda.
      retries: 5    # É o número de tentativas consecutivas que precisam falhar antes do container ser considerado unhealthy.

  redis:
    container_name: redis_MySecond_Ecommerce
    image: redis:8.0-alpine3.21
    command: redis-server --bind 0.0.0.0
    ports:
      - 6379:6379
    networks:
      - my-second-ecommerce
    volumes:
      - db_redis_mySecond_Ecommerce:/data

  pgadmin:
    container_name: pgadmin_MySecond_Ecommerce
    image: dpage/pgadmin4
    environment:
       PGADMIN_DEFAULT_EMAIL: ${PGADMIN_USER}
       PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD}
    ports:
       - 5050:80
    networks:
      - my-second-ecommerce
    depends_on:
      - postgres
    volumes:
      - db_pgadmin_mySecond_Ecommerce:/pgadmin_data:/var/lib/pgadmin
    user: "5050:5050"

networks:
  my-second-ecommerce:
    name: my-second-ecommerce
    driver: bridge

volumes:
  db_postgres_mySecond_Ecommerce:
  db_redis_mySecond_Ecommerce:
  db_pgadmin_mySecond_Ecommerce:
